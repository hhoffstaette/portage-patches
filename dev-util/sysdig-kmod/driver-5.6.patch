commit ad6939dd40105ded5d06b5844449dcbddee006fa
Author: Holger Hoffstätte <holger@applied-asynchrony.com>
Date:   Sat Apr 4 17:29:23 2020 +0200

    Fixes to compile with kernel 5.6 (#1609)
    
    Forward-port the code to >= 5.6 and provide backwards-compatible defines
    for compilation on older kernels.
    
    sysdig-CLA-1.0-signed-off-by: Holger Hoffstätte <holger@applied-asynchrony.com>

diff --git a/driver/main.c b/driver/main.c
index fa50e407..136f15fa 100644
--- a/driver/main.c
+++ b/driver/main.c
@@ -117,7 +117,7 @@ static int ppm_mmap(struct file *filp, struct vm_area_struct *vma);
 static int record_event_consumer(struct ppm_consumer_t *consumer,
 	enum ppm_event_type event_type,
 	enum syscall_flags drop_flags,
-	struct timespec *ts,
+	struct timespec64 *ts,
 	struct event_data_t *event_datap);
 static void record_event_all_consumers(enum ppm_event_type event_type,
 	enum syscall_flags drop_flags,
@@ -830,7 +830,7 @@ cleanup_ioctl_procinfo:
 	case PPM_IOCTL_DISABLE_DROPPING_MODE:
 	{
 		struct event_data_t event_data;
-		struct timespec ts;
+		struct timespec64 ts;
 
 		vpr_info("PPM_IOCTL_DISABLE_DROPPING_MODE, consumer %p\n", consumer_id);
 
@@ -842,7 +842,7 @@ cleanup_ioctl_procinfo:
 		 * Push an event into the ring buffer so that the user can know that dropping
 		 * mode has been disabled
 		 */
-		getnstimeofday(&ts);
+		ktime_get_real_ts64(&ts);
 		event_data.category = PPMC_CONTEXT_SWITCH;
 		event_data.event_info.context_data.sched_prev = (void *)DEI_DISABLE_DROPPING;
 		event_data.event_info.context_data.sched_next = (void *)0;
@@ -1397,7 +1397,7 @@ static enum ppm_event_type parse_socketcall(struct event_filler_arguments *fille
 #endif /* _HAS_SOCKETCALL */
 
 static inline void record_drop_e(struct ppm_consumer_t *consumer,
-                                 struct timespec *ts,
+                                 struct timespec64 *ts,
                                  enum syscall_flags drop_flags)
 {
 	struct event_data_t event_data = {0};
@@ -1414,7 +1414,7 @@ static inline void record_drop_e(struct ppm_consumer_t *consumer,
 }
 
 static inline void record_drop_x(struct ppm_consumer_t *consumer,
-                                 struct timespec *ts,
+                                 struct timespec64 *ts,
                                  enum syscall_flags drop_flags)
 {
 	struct event_data_t event_data = {0};
@@ -1496,7 +1496,7 @@ static inline int drop_nostate_event(enum ppm_event_type event_type,
 static inline int drop_event(struct ppm_consumer_t *consumer,
 			     enum ppm_event_type event_type,
 			     enum syscall_flags drop_flags,
-			     struct timespec *ts,
+			     struct timespec64 *ts,
 			     struct pt_regs *regs)
 {
 	int maybe_ret = 0;
@@ -1541,9 +1541,9 @@ static void record_event_all_consumers(enum ppm_event_type event_type,
 	struct event_data_t *event_datap)
 {
 	struct ppm_consumer_t *consumer;
-	struct timespec ts;
+	struct timespec64 ts;
 
-	getnstimeofday(&ts);
+	ktime_get_real_ts64(&ts);
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(consumer, &g_consumer_list, node) {
@@ -1558,7 +1558,7 @@ static void record_event_all_consumers(enum ppm_event_type event_type,
 static int record_event_consumer(struct ppm_consumer_t *consumer,
 	enum ppm_event_type event_type,
 	enum syscall_flags drop_flags,
-	struct timespec *ts,
+	struct timespec64 *ts,
 	struct event_data_t *event_datap)
 {
 	int res = 0;
@@ -1712,7 +1712,7 @@ static int record_event_consumer(struct ppm_consumer_t *consumer,
 #ifdef PPM_ENABLE_SENTINEL
 		hdr->sentinel_begin = ring->nevents;
 #endif
-		hdr->ts = timespec_to_ns(ts);
+		hdr->ts = timespec64_to_ns(ts);
 		hdr->tid = current->pid;
 		hdr->type = event_type;
 		hdr->nparams = args.nargs;
@@ -2244,7 +2244,7 @@ static void reset_ring_buffer(struct ppm_ring_buffer_context *ring)
 	ring->info->n_drops_pf = 0;
 	ring->info->n_preemptions = 0;
 	ring->info->n_context_switches = 0;
-	getnstimeofday(&ring->last_print_time);
+	ktime_get_real_ts64(&ring->last_print_time);
 }
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
diff --git a/driver/ppm.h b/driver/ppm.h
index acd5fa01..d95c01de 100644
--- a/driver/ppm.h
+++ b/driver/ppm.h
@@ -23,6 +23,14 @@ or GPL2.txt for full copies of the license.
 
 #include <linux/time.h>
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0)
+#define timespec64 timespec
+#define timespec64_to_ns timespec_to_ns
+#define ktime_get_real_ts64 getnstimeofday
+#define __kernel_old_timeval timeval
+#define old_timespec32 compat_timespec
+#endif
+
 /*
  * Global defines
  */
@@ -51,7 +59,7 @@ struct ppm_ring_buffer_context {
 	bool capture_enabled;
 	struct ppm_ring_buffer_info *info;
 	char *buffer;
-	struct timespec last_print_time;
+	struct timespec64 last_print_time;
 	u32 nevents;
 	atomic_t preempt_count;
 	char *str_storage;	/* String storage. Size is one page. */
diff --git a/driver/ppm_fillers.c b/driver/ppm_fillers.c
index 66d28f25..fc4e5b59 100644
--- a/driver/ppm_fillers.c
+++ b/driver/ppm_fillers.c
@@ -1345,7 +1345,7 @@ static int parse_sockopt(struct event_filler_arguments *args, int level, int opt
 	union {
 		uint32_t val32;
 		uint64_t val64;
-		struct timeval tv;
+		struct __kernel_old_timeval tv;
 	} u;
 
 	if (level == SOL_SOCKET) {
@@ -2694,9 +2694,9 @@ static int timespec_parse(struct event_filler_arguments *args, unsigned long val
 {
 	uint64_t longtime;
 	char *targetbuf = args->str_storage;
-	struct timespec *tts = (struct timespec *)targetbuf;
+	struct timespec64 *tts = (struct timespec64 *)targetbuf;
 #ifdef CONFIG_COMPAT
-	struct compat_timespec *compat_tts = (struct compat_timespec *)targetbuf;
+	struct old_timespec32 *compat_tts = (struct old_timespec32 *)targetbuf;
 #endif
 	int cfulen;
 
@@ -2707,14 +2707,14 @@ static int timespec_parse(struct event_filler_arguments *args, unsigned long val
 #ifdef CONFIG_COMPAT
 	if (!args->compat) {
 #endif
-		cfulen = (int)ppm_copy_from_user(targetbuf, (void __user *)val, sizeof(struct timespec));
+		cfulen = (int)ppm_copy_from_user(targetbuf, (void __user *)val, sizeof(struct timespec64));
 		if (unlikely(cfulen != 0))
 			return PPM_FAILURE_INVALID_USER_MEMORY;
 
 		longtime = ((uint64_t)tts->tv_sec) * 1000000000 + tts->tv_nsec;
 #ifdef CONFIG_COMPAT
 	} else {
-		cfulen = (int)ppm_copy_from_user(targetbuf, (void __user *)compat_ptr(val), sizeof(struct compat_timespec));
+		cfulen = (int)ppm_copy_from_user(targetbuf, (void __user *)compat_ptr(val), sizeof(struct old_timespec32));
 		if (unlikely(cfulen != 0))
 			return PPM_FAILURE_INVALID_USER_MEMORY;
 
